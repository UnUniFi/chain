// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nftfactory/nftfactory.proto

package types

import (
	fmt "fmt"
	github_com_UnUniFi_chain_types "github.com/UnUniFi/chain/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MintingPermission int32

const (
	MintingPermission_OnlyOwner MintingPermission = 0
	MintingPermission_Anyone    MintingPermission = 1
)

var MintingPermission_name = map[int32]string{
	0: "OnlyOwner",
	1: "Anyone",
}

var MintingPermission_value = map[string]int32{
	"OnlyOwner": 0,
	"Anyone":    1,
}

func (x MintingPermission) String() string {
	return proto.EnumName(MintingPermission_name, int32(x))
}

func (MintingPermission) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_364e0b9c5239b1de, []int{0}
}

type ClassAttributes struct {
	ClassId           string                                          `protobuf:"bytes,1,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	Owner             github_com_UnUniFi_chain_types.StringAccAddress `protobuf:"bytes,2,opt,name=owner,proto3,customtype=github.com/UnUniFi/chain/types.StringAccAddress" json:"owner" yaml:"owner"`
	BaseTokenUri      string                                          `protobuf:"bytes,3,opt,name=base_token_uri,json=baseTokenUri,proto3" json:"base_token_uri,omitempty"`
	MintingPermission MintingPermission                               `protobuf:"varint,4,opt,name=minting_permission,json=mintingPermission,proto3,enum=ununifi.nftfactory.MintingPermission" json:"minting_permission,omitempty"`
	TokenSupplyCap    uint64                                          `protobuf:"varint,5,opt,name=token_supply_cap,json=tokenSupplyCap,proto3" json:"token_supply_cap,omitempty"`
}

func (m *ClassAttributes) Reset()         { *m = ClassAttributes{} }
func (m *ClassAttributes) String() string { return proto.CompactTextString(m) }
func (*ClassAttributes) ProtoMessage()    {}
func (*ClassAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_364e0b9c5239b1de, []int{0}
}
func (m *ClassAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassAttributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassAttributes.Merge(m, src)
}
func (m *ClassAttributes) XXX_Size() int {
	return m.Size()
}
func (m *ClassAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_ClassAttributes proto.InternalMessageInfo

func (m *ClassAttributes) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *ClassAttributes) GetBaseTokenUri() string {
	if m != nil {
		return m.BaseTokenUri
	}
	return ""
}

func (m *ClassAttributes) GetMintingPermission() MintingPermission {
	if m != nil {
		return m.MintingPermission
	}
	return MintingPermission_OnlyOwner
}

func (m *ClassAttributes) GetTokenSupplyCap() uint64 {
	if m != nil {
		return m.TokenSupplyCap
	}
	return 0
}

type OwningClassIdList struct {
	Owner   github_com_UnUniFi_chain_types.StringAccAddress `protobuf:"bytes,1,opt,name=owner,proto3,customtype=github.com/UnUniFi/chain/types.StringAccAddress" json:"owner" yaml:"owner"`
	ClassId []string                                        `protobuf:"bytes,2,rep,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
}

func (m *OwningClassIdList) Reset()         { *m = OwningClassIdList{} }
func (m *OwningClassIdList) String() string { return proto.CompactTextString(m) }
func (*OwningClassIdList) ProtoMessage()    {}
func (*OwningClassIdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_364e0b9c5239b1de, []int{1}
}
func (m *OwningClassIdList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwningClassIdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwningClassIdList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwningClassIdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwningClassIdList.Merge(m, src)
}
func (m *OwningClassIdList) XXX_Size() int {
	return m.Size()
}
func (m *OwningClassIdList) XXX_DiscardUnknown() {
	xxx_messageInfo_OwningClassIdList.DiscardUnknown(m)
}

var xxx_messageInfo_OwningClassIdList proto.InternalMessageInfo

func (m *OwningClassIdList) GetClassId() []string {
	if m != nil {
		return m.ClassId
	}
	return nil
}

type ClassNameIdList struct {
	ClassName string   `protobuf:"bytes,1,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	ClassId   []string `protobuf:"bytes,2,rep,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
}

func (m *ClassNameIdList) Reset()         { *m = ClassNameIdList{} }
func (m *ClassNameIdList) String() string { return proto.CompactTextString(m) }
func (*ClassNameIdList) ProtoMessage()    {}
func (*ClassNameIdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_364e0b9c5239b1de, []int{2}
}
func (m *ClassNameIdList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassNameIdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassNameIdList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassNameIdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassNameIdList.Merge(m, src)
}
func (m *ClassNameIdList) XXX_Size() int {
	return m.Size()
}
func (m *ClassNameIdList) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassNameIdList.DiscardUnknown(m)
}

var xxx_messageInfo_ClassNameIdList proto.InternalMessageInfo

func (m *ClassNameIdList) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *ClassNameIdList) GetClassId() []string {
	if m != nil {
		return m.ClassId
	}
	return nil
}

type Params struct {
	MaxNFTSupplyCap   uint64 `protobuf:"varint,1,opt,name=MaxNFTSupplyCap,proto3" json:"MaxNFTSupplyCap,omitempty"`
	MinClassNameLen   uint64 `protobuf:"varint,2,opt,name=MinClassNameLen,proto3" json:"MinClassNameLen,omitempty"`
	MaxClassNameLen   uint64 `protobuf:"varint,3,opt,name=MaxClassNameLen,proto3" json:"MaxClassNameLen,omitempty"`
	MinUriLen         uint64 `protobuf:"varint,4,opt,name=MinUriLen,proto3" json:"MinUriLen,omitempty"`
	MaxUriLen         uint64 `protobuf:"varint,5,opt,name=MaxUriLen,proto3" json:"MaxUriLen,omitempty"`
	MaxSymbolLen      uint64 `protobuf:"varint,6,opt,name=MaxSymbolLen,proto3" json:"MaxSymbolLen,omitempty"`
	MaxDescriptionLen uint64 `protobuf:"varint,7,opt,name=MaxDescriptionLen,proto3" json:"MaxDescriptionLen,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_364e0b9c5239b1de, []int{3}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxNFTSupplyCap() uint64 {
	if m != nil {
		return m.MaxNFTSupplyCap
	}
	return 0
}

func (m *Params) GetMinClassNameLen() uint64 {
	if m != nil {
		return m.MinClassNameLen
	}
	return 0
}

func (m *Params) GetMaxClassNameLen() uint64 {
	if m != nil {
		return m.MaxClassNameLen
	}
	return 0
}

func (m *Params) GetMinUriLen() uint64 {
	if m != nil {
		return m.MinUriLen
	}
	return 0
}

func (m *Params) GetMaxUriLen() uint64 {
	if m != nil {
		return m.MaxUriLen
	}
	return 0
}

func (m *Params) GetMaxSymbolLen() uint64 {
	if m != nil {
		return m.MaxSymbolLen
	}
	return 0
}

func (m *Params) GetMaxDescriptionLen() uint64 {
	if m != nil {
		return m.MaxDescriptionLen
	}
	return 0
}

func init() {
	proto.RegisterEnum("ununifi.nftfactory.MintingPermission", MintingPermission_name, MintingPermission_value)
	proto.RegisterType((*ClassAttributes)(nil), "ununifi.nftfactory.ClassAttributes")
	proto.RegisterType((*OwningClassIdList)(nil), "ununifi.nftfactory.OwningClassIdList")
	proto.RegisterType((*ClassNameIdList)(nil), "ununifi.nftfactory.ClassNameIdList")
	proto.RegisterType((*Params)(nil), "ununifi.nftfactory.Params")
}

func init() { proto.RegisterFile("nftfactory/nftfactory.proto", fileDescriptor_364e0b9c5239b1de) }

var fileDescriptor_364e0b9c5239b1de = []byte{
	// 556 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x93, 0xcd, 0x6e, 0xd3, 0x4e,
	0x10, 0xc0, 0xe3, 0x34, 0x49, 0xff, 0x59, 0xe5, 0x9f, 0x26, 0x2b, 0x0e, 0xa1, 0x80, 0x13, 0x59,
	0x20, 0x45, 0x80, 0x6c, 0x09, 0x6e, 0xdc, 0xd2, 0x40, 0x11, 0xa2, 0x69, 0xaa, 0x7c, 0x5c, 0x90,
	0x50, 0xb4, 0x76, 0x36, 0xee, 0x08, 0x7b, 0xd7, 0xf2, 0xae, 0xd5, 0xf8, 0x21, 0x90, 0x38, 0xf0,
	0x22, 0xbc, 0x45, 0x8f, 0x3d, 0x22, 0x0e, 0x11, 0x4a, 0xde, 0x80, 0x27, 0x40, 0x5e, 0xbb, 0xf9,
	0x68, 0x04, 0x37, 0x6e, 0xbb, 0xbf, 0xf9, 0x69, 0x76, 0x77, 0x66, 0x16, 0x3d, 0x60, 0x33, 0x39,
	0x23, 0x8e, 0xe4, 0x61, 0x6c, 0x6d, 0x96, 0x66, 0x10, 0x72, 0xc9, 0x31, 0x8e, 0x58, 0xc4, 0x60,
	0x06, 0xe6, 0x26, 0x72, 0x7c, 0xcf, 0xe5, 0x2e, 0x57, 0x61, 0x2b, 0x59, 0xa5, 0xe6, 0x71, 0xd3,
	0xe5, 0xdc, 0xf5, 0xa8, 0xa5, 0x76, 0x76, 0x34, 0xb3, 0x24, 0xf8, 0x54, 0x48, 0xe2, 0x07, 0xa9,
	0x60, 0x7c, 0xcb, 0xa3, 0xa3, 0xae, 0x47, 0x84, 0xe8, 0x48, 0x19, 0x82, 0x1d, 0x49, 0x2a, 0xf0,
	0x7d, 0xf4, 0x9f, 0x93, 0xa0, 0x09, 0x4c, 0x1b, 0x5a, 0x4b, 0x6b, 0x97, 0x07, 0x87, 0x6a, 0xff,
	0x6e, 0x8a, 0x3f, 0xa2, 0x22, 0xbf, 0x62, 0x34, 0x6c, 0xe4, 0x13, 0x7e, 0xf2, 0xf6, 0x7a, 0xd1,
	0xcc, 0xfd, 0x58, 0x34, 0x2d, 0x17, 0xe4, 0x65, 0x64, 0x9b, 0x0e, 0xf7, 0xad, 0x31, 0x1b, 0x33,
	0x38, 0x05, 0xcb, 0xb9, 0x24, 0xc0, 0x2c, 0x19, 0x07, 0x54, 0x98, 0x43, 0x19, 0x02, 0x73, 0x3b,
	0x8e, 0xd3, 0x99, 0x4e, 0x43, 0x2a, 0xc4, 0xaf, 0x45, 0xb3, 0x12, 0x13, 0xdf, 0x7b, 0x65, 0xa8,
	0x6c, 0xc6, 0x20, 0xcd, 0x8a, 0x1f, 0xa3, 0xaa, 0x4d, 0x04, 0x9d, 0x48, 0xfe, 0x89, 0xb2, 0x49,
	0x14, 0x42, 0xe3, 0x40, 0x9d, 0x5f, 0x49, 0xe8, 0x28, 0x81, 0xe3, 0x10, 0xf0, 0x08, 0x61, 0x1f,
	0x98, 0x04, 0xe6, 0x4e, 0x02, 0x1a, 0xfa, 0x20, 0x04, 0x70, 0xd6, 0x28, 0xb4, 0xb4, 0x76, 0xf5,
	0xc5, 0x13, 0x73, 0xbf, 0x36, 0x66, 0x2f, 0xb5, 0x2f, 0xd6, 0xf2, 0xa0, 0xee, 0xdf, 0x45, 0xb8,
	0x8d, 0x6a, 0xe9, 0xb1, 0x22, 0x0a, 0x02, 0x2f, 0x9e, 0x38, 0x24, 0x68, 0x14, 0x5b, 0x5a, 0xbb,
	0x30, 0xa8, 0x2a, 0x3e, 0x54, 0xb8, 0x4b, 0x02, 0xe3, 0xb3, 0x86, 0xea, 0xfd, 0x2b, 0x06, 0xcc,
	0xed, 0xa6, 0x65, 0x39, 0x03, 0x21, 0x37, 0xa5, 0xd1, 0xfe, 0x49, 0x69, 0xb6, 0x9b, 0x92, 0x6f,
	0x1d, 0x6c, 0x35, 0xc5, 0x78, 0x9f, 0xb5, 0xf0, 0x9c, 0xf8, 0x34, 0xbb, 0xcc, 0x23, 0x84, 0x52,
	0x9b, 0x11, 0x9f, 0x66, 0x4d, 0x2c, 0x3b, 0xb7, 0xd2, 0xdf, 0x92, 0x7d, 0xcd, 0xa3, 0xd2, 0x05,
	0x09, 0x89, 0x2f, 0x70, 0x1b, 0x1d, 0xf5, 0xc8, 0xfc, 0xfc, 0x74, 0xb4, 0x7e, 0xba, 0xca, 0x54,
	0x18, 0xdc, 0xc5, 0xca, 0x04, 0xb6, 0xbe, 0xc4, 0x19, 0x65, 0x6a, 0x40, 0x12, 0x73, 0x17, 0x67,
	0x39, 0x77, 0xcc, 0x83, 0x75, 0xce, 0x1d, 0xf3, 0x21, 0x2a, 0xf7, 0x20, 0xe9, 0x77, 0xe2, 0x14,
	0x94, 0xb3, 0x01, 0x2a, 0x4a, 0xe6, 0x59, 0xb4, 0x98, 0x45, 0x6f, 0x01, 0x36, 0x50, 0xa5, 0x47,
	0xe6, 0xc3, 0xd8, 0xb7, 0xb9, 0x97, 0x08, 0x25, 0x25, 0xec, 0x30, 0xfc, 0x1c, 0xd5, 0x7b, 0x64,
	0xfe, 0x9a, 0x0a, 0x27, 0x84, 0x40, 0x02, 0x67, 0x89, 0x78, 0xa8, 0xc4, 0xfd, 0xc0, 0x53, 0x13,
	0xd5, 0xf7, 0xa6, 0x08, 0xff, 0x8f, 0xca, 0x7d, 0xe6, 0xc5, 0xfd, 0xa4, 0x41, 0xb5, 0x1c, 0x46,
	0xa8, 0xd4, 0x61, 0x31, 0x67, 0xb4, 0xa6, 0x9d, 0xbc, 0xb9, 0x5e, 0xea, 0xda, 0xcd, 0x52, 0xd7,
	0x7e, 0x2e, 0x75, 0xed, 0xcb, 0x4a, 0xcf, 0xdd, 0xac, 0xf4, 0xdc, 0xf7, 0x95, 0x9e, 0xfb, 0xf0,
	0xec, 0x8f, 0x03, 0x31, 0xdf, 0xfa, 0xe9, 0xe9, 0x74, 0xd8, 0x25, 0xf5, 0x4b, 0x5f, 0xfe, 0x0e,
	0x00, 0x00, 0xff, 0xff, 0xbf, 0xde, 0x21, 0x86, 0x0f, 0x04, 0x00, 0x00,
}

func (m *ClassAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TokenSupplyCap != 0 {
		i = encodeVarintNftfactory(dAtA, i, uint64(m.TokenSupplyCap))
		i--
		dAtA[i] = 0x28
	}
	if m.MintingPermission != 0 {
		i = encodeVarintNftfactory(dAtA, i, uint64(m.MintingPermission))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BaseTokenUri) > 0 {
		i -= len(m.BaseTokenUri)
		copy(dAtA[i:], m.BaseTokenUri)
		i = encodeVarintNftfactory(dAtA, i, uint64(len(m.BaseTokenUri)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Owner.Size()
		i -= size
		if _, err := m.Owner.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintNftfactory(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintNftfactory(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OwningClassIdList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwningClassIdList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OwningClassIdList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClassId) > 0 {
		for iNdEx := len(m.ClassId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ClassId[iNdEx])
			copy(dAtA[i:], m.ClassId[iNdEx])
			i = encodeVarintNftfactory(dAtA, i, uint64(len(m.ClassId[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.Owner.Size()
		i -= size
		if _, err := m.Owner.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintNftfactory(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClassNameIdList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassNameIdList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassNameIdList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClassId) > 0 {
		for iNdEx := len(m.ClassId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ClassId[iNdEx])
			copy(dAtA[i:], m.ClassId[iNdEx])
			i = encodeVarintNftfactory(dAtA, i, uint64(len(m.ClassId[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintNftfactory(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxDescriptionLen != 0 {
		i = encodeVarintNftfactory(dAtA, i, uint64(m.MaxDescriptionLen))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxSymbolLen != 0 {
		i = encodeVarintNftfactory(dAtA, i, uint64(m.MaxSymbolLen))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxUriLen != 0 {
		i = encodeVarintNftfactory(dAtA, i, uint64(m.MaxUriLen))
		i--
		dAtA[i] = 0x28
	}
	if m.MinUriLen != 0 {
		i = encodeVarintNftfactory(dAtA, i, uint64(m.MinUriLen))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxClassNameLen != 0 {
		i = encodeVarintNftfactory(dAtA, i, uint64(m.MaxClassNameLen))
		i--
		dAtA[i] = 0x18
	}
	if m.MinClassNameLen != 0 {
		i = encodeVarintNftfactory(dAtA, i, uint64(m.MinClassNameLen))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxNFTSupplyCap != 0 {
		i = encodeVarintNftfactory(dAtA, i, uint64(m.MaxNFTSupplyCap))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNftfactory(dAtA []byte, offset int, v uint64) int {
	offset -= sovNftfactory(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClassAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovNftfactory(uint64(l))
	}
	l = m.Owner.Size()
	n += 1 + l + sovNftfactory(uint64(l))
	l = len(m.BaseTokenUri)
	if l > 0 {
		n += 1 + l + sovNftfactory(uint64(l))
	}
	if m.MintingPermission != 0 {
		n += 1 + sovNftfactory(uint64(m.MintingPermission))
	}
	if m.TokenSupplyCap != 0 {
		n += 1 + sovNftfactory(uint64(m.TokenSupplyCap))
	}
	return n
}

func (m *OwningClassIdList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Owner.Size()
	n += 1 + l + sovNftfactory(uint64(l))
	if len(m.ClassId) > 0 {
		for _, s := range m.ClassId {
			l = len(s)
			n += 1 + l + sovNftfactory(uint64(l))
		}
	}
	return n
}

func (m *ClassNameIdList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovNftfactory(uint64(l))
	}
	if len(m.ClassId) > 0 {
		for _, s := range m.ClassId {
			l = len(s)
			n += 1 + l + sovNftfactory(uint64(l))
		}
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxNFTSupplyCap != 0 {
		n += 1 + sovNftfactory(uint64(m.MaxNFTSupplyCap))
	}
	if m.MinClassNameLen != 0 {
		n += 1 + sovNftfactory(uint64(m.MinClassNameLen))
	}
	if m.MaxClassNameLen != 0 {
		n += 1 + sovNftfactory(uint64(m.MaxClassNameLen))
	}
	if m.MinUriLen != 0 {
		n += 1 + sovNftfactory(uint64(m.MinUriLen))
	}
	if m.MaxUriLen != 0 {
		n += 1 + sovNftfactory(uint64(m.MaxUriLen))
	}
	if m.MaxSymbolLen != 0 {
		n += 1 + sovNftfactory(uint64(m.MaxSymbolLen))
	}
	if m.MaxDescriptionLen != 0 {
		n += 1 + sovNftfactory(uint64(m.MaxDescriptionLen))
	}
	return n
}

func sovNftfactory(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNftfactory(x uint64) (n int) {
	return sovNftfactory(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClassAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNftfactory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNftfactory
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNftfactory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNftfactory
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNftfactory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseTokenUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNftfactory
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNftfactory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseTokenUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintingPermission", wireType)
			}
			m.MintingPermission = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MintingPermission |= MintingPermission(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSupplyCap", wireType)
			}
			m.TokenSupplyCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenSupplyCap |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNftfactory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNftfactory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwningClassIdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNftfactory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwningClassIdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwningClassIdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNftfactory
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNftfactory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNftfactory
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNftfactory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = append(m.ClassId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNftfactory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNftfactory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassNameIdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNftfactory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassNameIdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassNameIdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNftfactory
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNftfactory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNftfactory
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNftfactory
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = append(m.ClassId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNftfactory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNftfactory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNftfactory
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNFTSupplyCap", wireType)
			}
			m.MaxNFTSupplyCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNFTSupplyCap |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinClassNameLen", wireType)
			}
			m.MinClassNameLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinClassNameLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxClassNameLen", wireType)
			}
			m.MaxClassNameLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxClassNameLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUriLen", wireType)
			}
			m.MinUriLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUriLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUriLen", wireType)
			}
			m.MaxUriLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUriLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSymbolLen", wireType)
			}
			m.MaxSymbolLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSymbolLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDescriptionLen", wireType)
			}
			m.MaxDescriptionLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDescriptionLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNftfactory(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNftfactory
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNftfactory(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNftfactory
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNftfactory
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNftfactory
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNftfactory
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNftfactory
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNftfactory        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNftfactory          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNftfactory = fmt.Errorf("proto: unexpected end of group")
)
