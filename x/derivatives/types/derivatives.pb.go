// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ununifi/derivatives/derivatives.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types1 "github.com/cosmos/cosmos-sdk/codec/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PositionType int32

const (
	PositionType_POSITION_UNKNOWN PositionType = 0
	PositionType_LONG             PositionType = 1
	PositionType_SHORT            PositionType = 2
)

var PositionType_name = map[int32]string{
	0: "POSITION_UNKNOWN",
	1: "LONG",
	2: "SHORT",
}

var PositionType_value = map[string]int32{
	"POSITION_UNKNOWN": 0,
	"LONG":             1,
	"SHORT":            2,
}

func (x PositionType) String() string {
	return proto.EnumName(PositionType_name, int32(x))
}

func (PositionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{0}
}

type MarketType int32

const (
	MarketType_UNKNOWN MarketType = 0
	MarketType_FUTURES MarketType = 1
	MarketType_OPTIONS MarketType = 2
)

var MarketType_name = map[int32]string{
	0: "UNKNOWN",
	1: "FUTURES",
	2: "OPTIONS",
}

var MarketType_value = map[string]int32{
	"UNKNOWN": 0,
	"FUTURES": 1,
	"OPTIONS": 2,
}

func (x MarketType) String() string {
	return proto.EnumName(MarketType_name, int32(x))
}

func (MarketType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{1}
}

type Position struct {
	Id                   string                                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" yaml:"id"`
	Market               Market                                 `protobuf:"bytes,2,opt,name=market,proto3" json:"market" yaml:"market"`
	Address              string                                 `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty" yaml:"address"`
	OpenedAt             time.Time                              `protobuf:"bytes,4,opt,name=opened_at,json=openedAt,proto3,stdtime" json:"opened_at" yaml:"opened_at"`
	OpenedHeight         uint64                                 `protobuf:"varint,5,opt,name=opened_height,json=openedHeight,proto3" json:"opened_height,omitempty" yaml:"opened_height"`
	OpenedBaseRate       github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=opened_base_rate,json=openedBaseRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"opened_base_rate" yaml:"opened_base_rate"`
	OpenedQuoteRate      github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=opened_quote_rate,json=openedQuoteRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"opened_quote_rate" yaml:"opened_quote_rate"`
	RemainingMargin      types.Coin                             `protobuf:"bytes,8,opt,name=remaining_margin,json=remainingMargin,proto3" json:"remaining_margin" yaml:"remaining_margin"`
	LeviedAmount         types.Coin                             `protobuf:"bytes,9,opt,name=levied_amount,json=leviedAmount,proto3" json:"levied_amount" yaml:"levied_amount"`
	LeviedAmountNegative bool                                   `protobuf:"varint,10,opt,name=levied_amount_negative,json=leviedAmountNegative,proto3" json:"levied_amount_negative,omitempty" yaml:"levied_amount_nagative"`
	LastLeviedAt         time.Time                              `protobuf:"bytes,11,opt,name=last_levied_at,json=lastLeviedAt,proto3,stdtime" json:"last_levied_at" yaml:"last_levied_at"`
	PositionInstance     types1.Any                             `protobuf:"bytes,12,opt,name=position_instance,json=positionInstance,proto3" json:"position_instance" yaml:"position_instance"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{0}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Position) GetMarket() Market {
	if m != nil {
		return m.Market
	}
	return Market{}
}

func (m *Position) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Position) GetOpenedAt() time.Time {
	if m != nil {
		return m.OpenedAt
	}
	return time.Time{}
}

func (m *Position) GetOpenedHeight() uint64 {
	if m != nil {
		return m.OpenedHeight
	}
	return 0
}

func (m *Position) GetRemainingMargin() types.Coin {
	if m != nil {
		return m.RemainingMargin
	}
	return types.Coin{}
}

func (m *Position) GetLeviedAmount() types.Coin {
	if m != nil {
		return m.LeviedAmount
	}
	return types.Coin{}
}

func (m *Position) GetLeviedAmountNegative() bool {
	if m != nil {
		return m.LeviedAmountNegative
	}
	return false
}

func (m *Position) GetLastLeviedAt() time.Time {
	if m != nil {
		return m.LastLeviedAt
	}
	return time.Time{}
}

func (m *Position) GetPositionInstance() types1.Any {
	if m != nil {
		return m.PositionInstance
	}
	return types1.Any{}
}

type QueriedPosition struct {
	Position              Position                               `protobuf:"bytes,1,opt,name=position,proto3" json:"position" yaml:"position"`
	ValuationProfit       types.Coin                             `protobuf:"bytes,2,opt,name=valuation_profit,json=valuationProfit,proto3" json:"valuation_profit" yaml:"valuation_profit"`
	RemainingMarginValue  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=remaining_margin_value,json=remainingMarginValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"remaining_margin_value" yaml:"remaining_margin_value"`
	EffectiveMargin       types.Coin                             `protobuf:"bytes,4,opt,name=effective_margin,json=effectiveMargin,proto3" json:"effective_margin" yaml:"effective_margin"`
	MarginMaintenanceRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=margin_maintenance_rate,json=marginMaintenanceRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"margin_maintenance_rate" yaml:"margin_maintenance_rate"`
}

func (m *QueriedPosition) Reset()         { *m = QueriedPosition{} }
func (m *QueriedPosition) String() string { return proto.CompactTextString(m) }
func (*QueriedPosition) ProtoMessage()    {}
func (*QueriedPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{1}
}
func (m *QueriedPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueriedPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueriedPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueriedPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueriedPosition.Merge(m, src)
}
func (m *QueriedPosition) XXX_Size() int {
	return m.Size()
}
func (m *QueriedPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_QueriedPosition.DiscardUnknown(m)
}

var xxx_messageInfo_QueriedPosition proto.InternalMessageInfo

func (m *QueriedPosition) GetPosition() Position {
	if m != nil {
		return m.Position
	}
	return Position{}
}

func (m *QueriedPosition) GetValuationProfit() types.Coin {
	if m != nil {
		return m.ValuationProfit
	}
	return types.Coin{}
}

func (m *QueriedPosition) GetEffectiveMargin() types.Coin {
	if m != nil {
		return m.EffectiveMargin
	}
	return types.Coin{}
}

type PoolAssetConf struct {
	Denom        string                                 `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
	TargetWeight github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=target_weight,json=targetWeight,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"target_weight" yaml:"target_weight"`
}

func (m *PoolAssetConf) Reset()         { *m = PoolAssetConf{} }
func (m *PoolAssetConf) String() string { return proto.CompactTextString(m) }
func (*PoolAssetConf) ProtoMessage()    {}
func (*PoolAssetConf) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{2}
}
func (m *PoolAssetConf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolAssetConf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolAssetConf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolAssetConf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolAssetConf.Merge(m, src)
}
func (m *PoolAssetConf) XXX_Size() int {
	return m.Size()
}
func (m *PoolAssetConf) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolAssetConf.DiscardUnknown(m)
}

var xxx_messageInfo_PoolAssetConf proto.InternalMessageInfo

func (m *PoolAssetConf) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type PoolParams struct {
	QuoteTicker                 string                                 `protobuf:"bytes,1,opt,name=quote_ticker,json=quoteTicker,proto3" json:"quote_ticker,omitempty" yaml:"quote_ticker"`
	BaseLptMintFee              github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=base_lpt_mint_fee,json=baseLptMintFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"base_lpt_mint_fee" yaml:"base_lpt_mint_fee"`
	BaseLptRedeemFee            github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=base_lpt_redeem_fee,json=baseLptRedeemFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"base_lpt_redeem_fee" yaml:"base_lpt_redeem_fee"`
	BorrowingFeeRatePerHour     github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=borrowing_fee_rate_per_hour,json=borrowingFeeRatePerHour,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"borrowing_fee_rate_per_hour" yaml:"borrowing_fee_rate_per_hour"`
	ReportLiquidationRewardRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=report_liquidation_reward_rate,json=reportLiquidationRewardRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"report_liquidation_reward_rate" yaml:"report_liquidation_reward_rate"`
	ReportLevyPeriodRewardRate  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=report_levy_period_reward_rate,json=reportLevyPeriodRewardRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"report_levy_period_reward_rate" yaml:"report_levy_period_reward_rate"`
	AcceptedAssetsConf          []PoolAssetConf                        `protobuf:"bytes,7,rep,name=accepted_assets_conf,json=acceptedAssetsConf,proto3" json:"accepted_assets_conf" yaml:"accepted_assets_conf"`
}

func (m *PoolParams) Reset()         { *m = PoolParams{} }
func (m *PoolParams) String() string { return proto.CompactTextString(m) }
func (*PoolParams) ProtoMessage()    {}
func (*PoolParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{3}
}
func (m *PoolParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolParams.Merge(m, src)
}
func (m *PoolParams) XXX_Size() int {
	return m.Size()
}
func (m *PoolParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolParams.DiscardUnknown(m)
}

var xxx_messageInfo_PoolParams proto.InternalMessageInfo

func (m *PoolParams) GetQuoteTicker() string {
	if m != nil {
		return m.QuoteTicker
	}
	return ""
}

func (m *PoolParams) GetAcceptedAssetsConf() []PoolAssetConf {
	if m != nil {
		return m.AcceptedAssetsConf
	}
	return nil
}

type PoolMarketCap struct {
	QuoteTicker string                                 `protobuf:"bytes,1,opt,name=quote_ticker,json=quoteTicker,proto3" json:"quote_ticker,omitempty" yaml:"quote_ticker"`
	Total       github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=total,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"total" yaml:"total"`
	AssetInfo   []PoolMarketCap_AssetInfo              `protobuf:"bytes,3,rep,name=asset_info,json=assetInfo,proto3" json:"asset_info" yaml:"asset_info"`
}

func (m *PoolMarketCap) Reset()         { *m = PoolMarketCap{} }
func (m *PoolMarketCap) String() string { return proto.CompactTextString(m) }
func (*PoolMarketCap) ProtoMessage()    {}
func (*PoolMarketCap) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{4}
}
func (m *PoolMarketCap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolMarketCap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolMarketCap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolMarketCap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolMarketCap.Merge(m, src)
}
func (m *PoolMarketCap) XXX_Size() int {
	return m.Size()
}
func (m *PoolMarketCap) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolMarketCap.DiscardUnknown(m)
}

var xxx_messageInfo_PoolMarketCap proto.InternalMessageInfo

func (m *PoolMarketCap) GetQuoteTicker() string {
	if m != nil {
		return m.QuoteTicker
	}
	return ""
}

func (m *PoolMarketCap) GetAssetInfo() []PoolMarketCap_AssetInfo {
	if m != nil {
		return m.AssetInfo
	}
	return nil
}

type PoolMarketCap_AssetInfo struct {
	Denom    string                                 `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
	Amount   github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount" yaml:"amount"`
	Price    github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=price,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"price" yaml:"price"`
	Reserved github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=reserved,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"reserved" yaml:"reserved"`
}

func (m *PoolMarketCap_AssetInfo) Reset()         { *m = PoolMarketCap_AssetInfo{} }
func (m *PoolMarketCap_AssetInfo) String() string { return proto.CompactTextString(m) }
func (*PoolMarketCap_AssetInfo) ProtoMessage()    {}
func (*PoolMarketCap_AssetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{4, 0}
}
func (m *PoolMarketCap_AssetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolMarketCap_AssetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolMarketCap_AssetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolMarketCap_AssetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolMarketCap_AssetInfo.Merge(m, src)
}
func (m *PoolMarketCap_AssetInfo) XXX_Size() int {
	return m.Size()
}
func (m *PoolMarketCap_AssetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolMarketCap_AssetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PoolMarketCap_AssetInfo proto.InternalMessageInfo

func (m *PoolMarketCap_AssetInfo) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type Market struct {
	BaseDenom  string `protobuf:"bytes,1,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty" yaml:"base_denom"`
	QuoteDenom string `protobuf:"bytes,2,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty" yaml:"quote_denom"`
}

func (m *Market) Reset()         { *m = Market{} }
func (m *Market) String() string { return proto.CompactTextString(m) }
func (*Market) ProtoMessage()    {}
func (*Market) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{5}
}
func (m *Market) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Market) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Market.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Market) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Market.Merge(m, src)
}
func (m *Market) XXX_Size() int {
	return m.Size()
}
func (m *Market) XXX_DiscardUnknown() {
	xxx_messageInfo_Market.DiscardUnknown(m)
}

var xxx_messageInfo_Market proto.InternalMessageInfo

func (m *Market) GetBaseDenom() string {
	if m != nil {
		return m.BaseDenom
	}
	return ""
}

func (m *Market) GetQuoteDenom() string {
	if m != nil {
		return m.QuoteDenom
	}
	return ""
}

type EventPriceIsNotFeeded struct {
	Asset string `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset,omitempty" yaml:"asset"`
}

func (m *EventPriceIsNotFeeded) Reset()         { *m = EventPriceIsNotFeeded{} }
func (m *EventPriceIsNotFeeded) String() string { return proto.CompactTextString(m) }
func (*EventPriceIsNotFeeded) ProtoMessage()    {}
func (*EventPriceIsNotFeeded) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{6}
}
func (m *EventPriceIsNotFeeded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPriceIsNotFeeded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPriceIsNotFeeded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPriceIsNotFeeded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPriceIsNotFeeded.Merge(m, src)
}
func (m *EventPriceIsNotFeeded) XXX_Size() int {
	return m.Size()
}
func (m *EventPriceIsNotFeeded) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPriceIsNotFeeded.DiscardUnknown(m)
}

var xxx_messageInfo_EventPriceIsNotFeeded proto.InternalMessageInfo

func (m *EventPriceIsNotFeeded) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

type Reserve struct {
	MarketType MarketType `protobuf:"varint,1,opt,name=market_type,json=marketType,proto3,enum=ununifi.derivatives.MarketType" json:"market_type,omitempty" yaml:"market_type"`
	Amount     types.Coin `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount" yaml:"amount"`
}

func (m *Reserve) Reset()         { *m = Reserve{} }
func (m *Reserve) String() string { return proto.CompactTextString(m) }
func (*Reserve) ProtoMessage()    {}
func (*Reserve) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a25a5cf1b44b970, []int{7}
}
func (m *Reserve) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reserve) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reserve.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reserve) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reserve.Merge(m, src)
}
func (m *Reserve) XXX_Size() int {
	return m.Size()
}
func (m *Reserve) XXX_DiscardUnknown() {
	xxx_messageInfo_Reserve.DiscardUnknown(m)
}

var xxx_messageInfo_Reserve proto.InternalMessageInfo

func (m *Reserve) GetMarketType() MarketType {
	if m != nil {
		return m.MarketType
	}
	return MarketType_UNKNOWN
}

func (m *Reserve) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

func init() {
	proto.RegisterEnum("ununifi.derivatives.PositionType", PositionType_name, PositionType_value)
	proto.RegisterEnum("ununifi.derivatives.MarketType", MarketType_name, MarketType_value)
	proto.RegisterType((*Position)(nil), "ununifi.derivatives.Position")
	proto.RegisterType((*QueriedPosition)(nil), "ununifi.derivatives.QueriedPosition")
	proto.RegisterType((*PoolAssetConf)(nil), "ununifi.derivatives.PoolAssetConf")
	proto.RegisterType((*PoolParams)(nil), "ununifi.derivatives.PoolParams")
	proto.RegisterType((*PoolMarketCap)(nil), "ununifi.derivatives.PoolMarketCap")
	proto.RegisterType((*PoolMarketCap_AssetInfo)(nil), "ununifi.derivatives.PoolMarketCap.AssetInfo")
	proto.RegisterType((*Market)(nil), "ununifi.derivatives.Market")
	proto.RegisterType((*EventPriceIsNotFeeded)(nil), "ununifi.derivatives.EventPriceIsNotFeeded")
	proto.RegisterType((*Reserve)(nil), "ununifi.derivatives.Reserve")
}

func init() {
	proto.RegisterFile("ununifi/derivatives/derivatives.proto", fileDescriptor_5a25a5cf1b44b970)
}

var fileDescriptor_5a25a5cf1b44b970 = []byte{
	// 1498 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4b, 0x6f, 0x1b, 0x45,
	0x1c, 0xcf, 0xa6, 0x79, 0xd8, 0x63, 0x27, 0x71, 0xa6, 0x49, 0xe3, 0x24, 0xc4, 0x9b, 0x0e, 0x6a,
	0x15, 0x55, 0xc5, 0x56, 0x53, 0x24, 0x44, 0x25, 0xa8, 0xe2, 0xb6, 0x21, 0x29, 0x79, 0xb8, 0x13,
	0x87, 0x20, 0x04, 0x5a, 0x6d, 0xbc, 0x63, 0x67, 0x14, 0x7b, 0xc6, 0xdd, 0x1d, 0x3b, 0x58, 0x9c,
	0x91, 0xe0, 0x82, 0x2a, 0xae, 0x70, 0xe4, 0xca, 0x87, 0xe0, 0x82, 0x7a, 0x41, 0xea, 0x11, 0x71,
	0x30, 0xa8, 0xfd, 0x06, 0xfe, 0x04, 0x68, 0x1e, 0xbb, 0x7e, 0x24, 0x7d, 0xb8, 0x70, 0x4a, 0xfe,
	0xaf, 0xdf, 0xff, 0xfd, 0xf7, 0x2c, 0xb8, 0xd6, 0x60, 0x0d, 0x46, 0xcb, 0x34, 0xe7, 0x11, 0x9f,
	0x36, 0x5d, 0x41, 0x9b, 0x24, 0xe8, 0xfd, 0x3f, 0x5b, 0xf7, 0xb9, 0xe0, 0xf0, 0xb2, 0x51, 0xcb,
	0xf6, 0x88, 0x96, 0x16, 0x2b, 0x9c, 0x57, 0xaa, 0x24, 0xa7, 0x54, 0x8e, 0x1b, 0xe5, 0x9c, 0xcb,
	0x5a, 0x5a, 0x7f, 0x69, 0xae, 0xc2, 0x2b, 0x5c, 0xfd, 0x9b, 0x93, 0xff, 0x19, 0xae, 0x3d, 0x68,
	0x20, 0x68, 0x8d, 0x04, 0xc2, 0xad, 0xd5, 0x8d, 0x42, 0xa6, 0xc4, 0x83, 0x1a, 0x0f, 0x72, 0xc7,
	0x6e, 0x40, 0x72, 0xcd, 0x5b, 0xc7, 0x44, 0xb8, 0xb7, 0x72, 0x25, 0x4e, 0x99, 0x91, 0x2f, 0x6a,
	0xb9, 0xa3, 0x91, 0x35, 0xa1, 0x45, 0xe8, 0x87, 0x18, 0x88, 0x15, 0x78, 0x40, 0x05, 0xe5, 0x0c,
	0xae, 0x80, 0x51, 0xea, 0xa5, 0xad, 0x55, 0x6b, 0x2d, 0x9e, 0x9f, 0xea, 0xb4, 0xed, 0x78, 0xcb,
	0xad, 0x55, 0xef, 0x20, 0xea, 0x21, 0x3c, 0x4a, 0x3d, 0xf8, 0x10, 0x4c, 0xd4, 0x5c, 0xff, 0x94,
	0x88, 0xf4, 0xe8, 0xaa, 0xb5, 0x96, 0x58, 0x5f, 0xce, 0x5e, 0x90, 0x5e, 0x76, 0x57, 0xa9, 0xe4,
	0xe7, 0x9f, 0xb6, 0xed, 0x91, 0x4e, 0xdb, 0x9e, 0xd2, 0x18, 0xda, 0x10, 0x61, 0x83, 0x00, 0x6f,
	0x82, 0x49, 0xd7, 0xf3, 0x7c, 0x12, 0x04, 0xe9, 0x4b, 0xca, 0x1f, 0xec, 0xb4, 0xed, 0x69, 0xad,
	0x6b, 0x04, 0x08, 0x87, 0x2a, 0xf0, 0x10, 0xc4, 0x79, 0x9d, 0x30, 0xe2, 0x39, 0xae, 0x48, 0x8f,
	0x29, 0xe7, 0x4b, 0x59, 0x5d, 0x95, 0x6c, 0x58, 0x95, 0x6c, 0x31, 0xac, 0x4a, 0xfe, 0x1d, 0xe3,
	0x3b, 0xa5, 0xf1, 0x22, 0x53, 0xf4, 0xe4, 0x6f, 0xdb, 0xc2, 0x31, 0x4d, 0x6f, 0x08, 0xf8, 0x11,
	0x98, 0x32, 0xb2, 0x13, 0x42, 0x2b, 0x27, 0x22, 0x3d, 0xbe, 0x6a, 0xad, 0x8d, 0xe5, 0xd3, 0x9d,
	0xb6, 0x3d, 0xd7, 0x67, 0xaa, 0xc5, 0x08, 0x27, 0x35, 0xbd, 0xa5, 0x48, 0x18, 0x80, 0x94, 0x91,
	0xcb, 0xc2, 0x3b, 0xbe, 0x2b, 0x48, 0x7a, 0x42, 0x25, 0xb3, 0x2d, 0x03, 0xf8, 0xab, 0x6d, 0x5f,
	0xaf, 0x50, 0x71, 0xd2, 0x38, 0xce, 0x96, 0x78, 0xcd, 0x94, 0xdd, 0xfc, 0x79, 0x2f, 0xf0, 0x4e,
	0x73, 0xa2, 0x55, 0x27, 0x41, 0xf6, 0x3e, 0x29, 0x75, 0xda, 0xf6, 0x42, 0x9f, 0xbf, 0x08, 0x0f,
	0xe1, 0x69, 0xcd, 0xca, 0xbb, 0x01, 0xc1, 0xae, 0x20, 0xb0, 0x09, 0x66, 0x8d, 0xd2, 0xe3, 0x06,
	0x17, 0xc6, 0xeb, 0xa4, 0xf2, 0xfa, 0x70, 0x68, 0xaf, 0xe9, 0x3e, 0xaf, 0x5d, 0x40, 0x84, 0x67,
	0x34, 0xef, 0x91, 0x64, 0x29, 0xbf, 0x04, 0xa4, 0x7c, 0x52, 0x73, 0x29, 0xa3, 0xac, 0xe2, 0xd4,
	0x5c, 0xbf, 0x42, 0x59, 0x3a, 0xa6, 0x3a, 0xb1, 0x98, 0x35, 0x13, 0x25, 0xa3, 0xce, 0x9a, 0xf1,
	0xcb, 0xde, 0xe3, 0x94, 0xe5, 0x6d, 0xd3, 0x08, 0x93, 0xdd, 0x20, 0x00, 0xc2, 0x33, 0x11, 0x6b,
	0x57, 0x71, 0xe0, 0x97, 0x60, 0xaa, 0x4a, 0x9a, 0x54, 0xb6, 0xab, 0xc6, 0x1b, 0x4c, 0xa4, 0xe3,
	0xaf, 0xf3, 0x11, 0x36, 0xdb, 0x74, 0xac, 0xcf, 0x1a, 0xe1, 0xa4, 0xa6, 0x37, 0x14, 0x09, 0x8f,
	0xc0, 0x95, 0x3e, 0xb9, 0xc3, 0x48, 0x45, 0x8d, 0x6d, 0x1a, 0xac, 0x5a, 0x6b, 0xb1, 0xfc, 0xd5,
	0x4e, 0xdb, 0x5e, 0xb9, 0x00, 0xc7, 0x61, 0xae, 0xd6, 0x43, 0x78, 0xae, 0x17, 0x70, 0xcf, 0x98,
	0xc3, 0x12, 0x98, 0xae, 0xba, 0x81, 0x70, 0x42, 0x2b, 0x91, 0x4e, 0xbc, 0x76, 0x4a, 0xaf, 0x9a,
	0xc0, 0xe7, 0x8d, 0xc3, 0x3e, 0x7b, 0x3d, 0xaa, 0x49, 0xc9, 0xdc, 0xd1, 0x0e, 0x05, 0x2c, 0x81,
	0xd9, 0xba, 0x59, 0x55, 0x87, 0xb2, 0x40, 0xb8, 0xac, 0x44, 0xd2, 0x49, 0xe5, 0x67, 0xee, 0x9c,
	0x9f, 0x0d, 0xd6, 0xca, 0xaf, 0x1a, 0x0f, 0xa6, 0xcd, 0xe7, 0x8c, 0x11, 0x4e, 0x85, 0xbc, 0xed,
	0x90, 0xf5, 0xfb, 0x18, 0x98, 0x79, 0xd4, 0x20, 0x3e, 0x25, 0x5e, 0x74, 0x17, 0x30, 0x88, 0x85,
	0x7a, 0xea, 0x3a, 0x24, 0xd6, 0x57, 0x2e, 0x5c, 0xfd, 0xd0, 0x20, 0xbf, 0x60, 0x1c, 0xcf, 0xf4,
	0x3b, 0x46, 0x38, 0xc2, 0x91, 0xf3, 0xd4, 0x74, 0xab, 0x0d, 0x57, 0x05, 0x54, 0xf7, 0x79, 0x99,
	0x86, 0x67, 0xe5, 0xcd, 0xe7, 0x69, 0x10, 0x00, 0xe1, 0x99, 0x88, 0x55, 0x50, 0x1c, 0xf8, 0xad,
	0x05, 0xae, 0x0c, 0x8e, 0x9d, 0x23, 0x95, 0x88, 0xb9, 0x3b, 0xfb, 0x43, 0x2f, 0xcd, 0xca, 0xc5,
	0xc3, 0xac, 0x51, 0x11, 0x9e, 0x1b, 0x18, 0xe9, 0xcf, 0x24, 0x5b, 0xa6, 0x4b, 0xca, 0x65, 0x52,
	0x92, 0x85, 0x0a, 0xd7, 0x67, 0x6c, 0xc8, 0x74, 0x07, 0x01, 0x10, 0x9e, 0x89, 0x58, 0x66, 0x7d,
	0xbe, 0xb3, 0xc0, 0x82, 0x09, 0x47, 0x06, 0x21, 0x08, 0x93, 0x4d, 0xd5, 0x47, 0x62, 0x5c, 0xe5,
	0x5b, 0x18, 0x3a, 0xdf, 0x4c, 0x74, 0xc1, 0x2f, 0x82, 0x45, 0x78, 0x5e, 0x4b, 0x76, 0xbb, 0x02,
	0x79, 0x30, 0xd0, 0x2f, 0x16, 0x98, 0x2a, 0x70, 0x5e, 0xdd, 0x08, 0x02, 0x22, 0xee, 0x71, 0x56,
	0x86, 0xd7, 0xc1, 0xb8, 0x47, 0x18, 0xaf, 0x99, 0x5f, 0x98, 0x54, 0xa7, 0x6d, 0x27, 0x35, 0xb6,
	0x62, 0x23, 0xac, 0xc5, 0xf0, 0x14, 0x4c, 0x09, 0xd7, 0xaf, 0x10, 0xe1, 0x9c, 0xe9, 0xb3, 0x3c,
	0xaa, 0xf4, 0x37, 0x87, 0x8e, 0xdc, 0x9c, 0x84, 0x3e, 0x30, 0x84, 0x93, 0x9a, 0x3e, 0xd2, 0xe4,
	0xf7, 0x93, 0x00, 0xc8, 0x30, 0x0b, 0xae, 0xef, 0xd6, 0x02, 0x78, 0x07, 0x24, 0xf5, 0x19, 0x14,
	0xb4, 0x74, 0x4a, 0x7c, 0x13, 0xea, 0x42, 0xa7, 0x6d, 0x5f, 0xd6, 0x60, 0xbd, 0x52, 0x84, 0x13,
	0x8a, 0x2c, 0x2a, 0x0a, 0x36, 0xc0, 0xac, 0x3a, 0xdc, 0xd5, 0xba, 0x70, 0x6a, 0x94, 0x09, 0xa7,
	0x4c, 0x88, 0x89, 0xfd, 0xad, 0x4f, 0xf3, 0x39, 0x40, 0x84, 0xa7, 0x25, 0x6f, 0xa7, 0x2e, 0x76,
	0x29, 0x13, 0x9b, 0x84, 0xc0, 0x6f, 0xc0, 0xe5, 0x48, 0xcb, 0x27, 0x1e, 0x21, 0x35, 0xe5, 0x58,
	0x8f, 0xf7, 0xce, 0xd0, 0x8e, 0x97, 0x06, 0x1c, 0x77, 0x21, 0x11, 0x4e, 0x19, 0xd7, 0x58, 0xf1,
	0xa4, 0xf3, 0x1f, 0x2d, 0xb0, 0x7c, 0xcc, 0x7d, 0x9f, 0x9f, 0xc9, 0x4d, 0x28, 0x13, 0x3d, 0x14,
	0x4e, 0x9d, 0xf8, 0xce, 0x09, 0x6f, 0xf8, 0x6a, 0xc6, 0xe3, 0xf9, 0xe2, 0xd0, 0x51, 0x20, 0x13,
	0xc5, 0xcb, 0xa1, 0x11, 0x5e, 0x88, 0xa4, 0x9b, 0x44, 0xcd, 0x5c, 0x81, 0xf8, 0x5b, 0xbc, 0xe1,
	0xc3, 0x9f, 0x2d, 0x90, 0xf1, 0x49, 0x9d, 0xfb, 0xc2, 0xa9, 0xd2, 0xc7, 0x0d, 0xea, 0xe9, 0x23,
	0xe1, 0x93, 0x33, 0xd7, 0xf7, 0x7a, 0x97, 0xe1, 0x68, 0xe8, 0xb8, 0xae, 0x85, 0xcb, 0xff, 0x2a,
	0x74, 0x84, 0x97, 0xb5, 0xc2, 0x4e, 0x57, 0x8e, 0x95, 0x58, 0xfd, 0x94, 0xfe, 0xd4, 0x13, 0x1e,
	0x69, 0xb6, 0x64, 0x46, 0x94, 0x7b, 0x7d, 0xe1, 0x4d, 0xfc, 0x3f, 0xe1, 0x5d, 0x8c, 0x8e, 0xf0,
	0x92, 0x09, 0x8f, 0x34, 0x5b, 0x05, 0x25, 0xee, 0x89, 0xae, 0x05, 0xe6, 0xdc, 0x52, 0x89, 0xd4,
	0x85, 0xfc, 0x1d, 0x92, 0xbb, 0x1b, 0x38, 0x25, 0xce, 0xca, 0xe9, 0xc9, 0xd5, 0x4b, 0x6b, 0x89,
	0x75, 0xf4, 0x92, 0xc3, 0xdf, 0xb3, 0xe7, 0xf9, 0x77, 0xcd, 0xd9, 0x5a, 0x36, 0xcf, 0xb9, 0x0b,
	0xd0, 0x10, 0x86, 0x21, 0x5b, 0xd9, 0x05, 0xd2, 0x10, 0xfd, 0x31, 0xa6, 0x4f, 0x86, 0x7e, 0x42,
	0xde, 0x73, 0xeb, 0xff, 0x69, 0x1d, 0x8b, 0x60, 0x5c, 0x70, 0xe1, 0x56, 0xcd, 0x0a, 0x7e, 0x3c,
	0x74, 0x31, 0xcd, 0x71, 0x52, 0x20, 0x08, 0x6b, 0x30, 0x58, 0x06, 0x40, 0xe5, 0xe1, 0x50, 0x56,
	0xe6, 0xe9, 0x4b, 0xaa, 0x28, 0x37, 0x5f, 0x5a, 0x94, 0x28, 0x93, 0xac, 0x4a, 0x73, 0x9b, 0x95,
	0x79, 0x7e, 0xd1, 0x94, 0x67, 0xd6, 0x94, 0x27, 0x42, 0x43, 0x38, 0xee, 0x86, 0x5a, 0x4b, 0xbf,
	0x8d, 0x82, 0x78, 0x64, 0xf3, 0xc6, 0xa7, 0xf3, 0x08, 0x4c, 0x98, 0x77, 0x93, 0x4e, 0xfa, 0xee,
	0x10, 0x49, 0x6f, 0x33, 0xd1, 0x7d, 0xaf, 0x87, 0xef, 0x27, 0x03, 0x27, 0x8b, 0x59, 0xf7, 0x69,
	0x29, 0x3c, 0x2b, 0x6f, 0x5d, 0x4c, 0x05, 0x82, 0xb0, 0x06, 0x83, 0x5f, 0x81, 0x98, 0x4f, 0x02,
	0xe2, 0x37, 0x89, 0x67, 0x2e, 0xc5, 0xc6, 0xd0, 0x01, 0xcf, 0x84, 0x23, 0xaf, 0x71, 0x10, 0x8e,
	0x20, 0xd1, 0x19, 0x98, 0xd0, 0x0d, 0x80, 0xef, 0x03, 0xa0, 0x0e, 0x5a, 0x6f, 0x11, 0xe7, 0xbb,
	0x3d, 0xe8, 0xca, 0x10, 0x8e, 0x4b, 0xe2, 0xbe, 0xaa, 0xe6, 0x07, 0x40, 0x0f, 0x94, 0x31, 0xd3,
	0x25, 0xbd, 0xd2, 0x69, 0xdb, 0xb0, 0x77, 0xf8, 0x8c, 0x1d, 0x50, 0x94, 0x32, 0x44, 0x77, 0xc1,
	0xfc, 0x83, 0x26, 0x61, 0xa2, 0x20, 0xb3, 0xdc, 0x0e, 0xf6, 0xb8, 0x3c, 0xd4, 0x1e, 0xf1, 0x64,
	0x1f, 0x55, 0x8b, 0xcf, 0xf7, 0x51, 0xb1, 0x11, 0xd6, 0x62, 0xf4, 0xab, 0x05, 0x26, 0xb1, 0x4e,
	0x03, 0x7e, 0x0e, 0x12, 0xfa, 0xa3, 0xc9, 0x91, 0x69, 0x2b, 0xcb, 0xe9, 0x75, 0xfb, 0x15, 0xdf,
	0x5e, 0xc5, 0x56, 0x9d, 0xf4, 0x86, 0xd9, 0x63, 0x8d, 0x30, 0xa8, 0x45, 0x3a, 0x70, 0xab, 0x6f,
	0x5a, 0x5e, 0xf9, 0x14, 0x19, 0xf8, 0x9c, 0x1b, 0x18, 0x8f, 0x1b, 0x1f, 0x82, 0x64, 0xf8, 0xf8,
	0x53, 0xc8, 0x73, 0x20, 0x55, 0xd8, 0x3f, 0xd8, 0x2e, 0x6e, 0xef, 0xef, 0x39, 0x87, 0x7b, 0x9f,
	0xee, 0xed, 0x1f, 0xed, 0xa5, 0x46, 0x60, 0x0c, 0x8c, 0xed, 0xec, 0xef, 0x7d, 0x92, 0xb2, 0x60,
	0x1c, 0x8c, 0x1f, 0x6c, 0xed, 0xe3, 0x62, 0x6a, 0xf4, 0xc6, 0x6d, 0x00, 0xba, 0x61, 0xc3, 0x04,
	0x98, 0xec, 0xea, 0x27, 0xc0, 0xe4, 0xe6, 0x61, 0xf1, 0x10, 0x3f, 0x38, 0x48, 0x59, 0x92, 0xd8,
	0x2f, 0x48, 0xc0, 0x83, 0xd4, 0x68, 0x7e, 0xf3, 0xe9, 0xf3, 0x8c, 0xf5, 0xec, 0x79, 0xc6, 0xfa,
	0xe7, 0x79, 0xc6, 0x7a, 0xf2, 0x22, 0x33, 0xf2, 0xec, 0x45, 0x66, 0xe4, 0xcf, 0x17, 0x99, 0x91,
	0x2f, 0x6e, 0xf6, 0x0c, 0xce, 0x21, 0x3b, 0x64, 0x74, 0x93, 0xe6, 0x4a, 0x27, 0x2e, 0x65, 0xb9,
	0xaf, 0xfb, 0x3e, 0xd6, 0xd5, 0x08, 0x1d, 0x4f, 0xa8, 0xf7, 0xf2, 0xed, 0x7f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x2d, 0xeb, 0xa8, 0x2d, 0xd0, 0x0f, 0x00, 0x00,
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PositionInstance.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastLeviedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastLeviedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintDerivatives(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x5a
	if m.LeviedAmountNegative {
		i--
		if m.LeviedAmountNegative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.LeviedAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.RemainingMargin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.OpenedQuoteRate.Size()
		i -= size
		if _, err := m.OpenedQuoteRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.OpenedBaseRate.Size()
		i -= size
		if _, err := m.OpenedBaseRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.OpenedHeight != 0 {
		i = encodeVarintDerivatives(dAtA, i, uint64(m.OpenedHeight))
		i--
		dAtA[i] = 0x28
	}
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.OpenedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.OpenedAt):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintDerivatives(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x22
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintDerivatives(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintDerivatives(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueriedPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueriedPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueriedPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MarginMaintenanceRate.Size()
		i -= size
		if _, err := m.MarginMaintenanceRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.EffectiveMargin.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.RemainingMarginValue.Size()
		i -= size
		if _, err := m.RemainingMarginValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ValuationProfit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolAssetConf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolAssetConf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolAssetConf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TargetWeight.Size()
		i -= size
		if _, err := m.TargetWeight.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintDerivatives(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoolParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptedAssetsConf) > 0 {
		for iNdEx := len(m.AcceptedAssetsConf) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AcceptedAssetsConf[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDerivatives(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	{
		size := m.ReportLevyPeriodRewardRate.Size()
		i -= size
		if _, err := m.ReportLevyPeriodRewardRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.ReportLiquidationRewardRate.Size()
		i -= size
		if _, err := m.ReportLiquidationRewardRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.BorrowingFeeRatePerHour.Size()
		i -= size
		if _, err := m.BorrowingFeeRatePerHour.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BaseLptRedeemFee.Size()
		i -= size
		if _, err := m.BaseLptRedeemFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.BaseLptMintFee.Size()
		i -= size
		if _, err := m.BaseLptMintFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.QuoteTicker) > 0 {
		i -= len(m.QuoteTicker)
		copy(dAtA[i:], m.QuoteTicker)
		i = encodeVarintDerivatives(dAtA, i, uint64(len(m.QuoteTicker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoolMarketCap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolMarketCap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolMarketCap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetInfo) > 0 {
		for iNdEx := len(m.AssetInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssetInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDerivatives(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.Total.Size()
		i -= size
		if _, err := m.Total.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.QuoteTicker) > 0 {
		i -= len(m.QuoteTicker)
		copy(dAtA[i:], m.QuoteTicker)
		i = encodeVarintDerivatives(dAtA, i, uint64(len(m.QuoteTicker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoolMarketCap_AssetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolMarketCap_AssetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolMarketCap_AssetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Reserved.Size()
		i -= size
		if _, err := m.Reserved.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintDerivatives(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Market) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Market) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Market) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintDerivatives(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintDerivatives(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPriceIsNotFeeded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPriceIsNotFeeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPriceIsNotFeeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Asset) > 0 {
		i -= len(m.Asset)
		copy(dAtA[i:], m.Asset)
		i = encodeVarintDerivatives(dAtA, i, uint64(len(m.Asset)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Reserve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reserve) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reserve) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDerivatives(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.MarketType != 0 {
		i = encodeVarintDerivatives(dAtA, i, uint64(m.MarketType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDerivatives(dAtA []byte, offset int, v uint64) int {
	offset -= sovDerivatives(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovDerivatives(uint64(l))
	}
	l = m.Market.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovDerivatives(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.OpenedAt)
	n += 1 + l + sovDerivatives(uint64(l))
	if m.OpenedHeight != 0 {
		n += 1 + sovDerivatives(uint64(m.OpenedHeight))
	}
	l = m.OpenedBaseRate.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.OpenedQuoteRate.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.RemainingMargin.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.LeviedAmount.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	if m.LeviedAmountNegative {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastLeviedAt)
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.PositionInstance.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	return n
}

func (m *QueriedPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Position.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.ValuationProfit.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.RemainingMarginValue.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.EffectiveMargin.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.MarginMaintenanceRate.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	return n
}

func (m *PoolAssetConf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovDerivatives(uint64(l))
	}
	l = m.TargetWeight.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	return n
}

func (m *PoolParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.QuoteTicker)
	if l > 0 {
		n += 1 + l + sovDerivatives(uint64(l))
	}
	l = m.BaseLptMintFee.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.BaseLptRedeemFee.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.BorrowingFeeRatePerHour.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.ReportLiquidationRewardRate.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.ReportLevyPeriodRewardRate.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	if len(m.AcceptedAssetsConf) > 0 {
		for _, e := range m.AcceptedAssetsConf {
			l = e.Size()
			n += 1 + l + sovDerivatives(uint64(l))
		}
	}
	return n
}

func (m *PoolMarketCap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.QuoteTicker)
	if l > 0 {
		n += 1 + l + sovDerivatives(uint64(l))
	}
	l = m.Total.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	if len(m.AssetInfo) > 0 {
		for _, e := range m.AssetInfo {
			l = e.Size()
			n += 1 + l + sovDerivatives(uint64(l))
		}
	}
	return n
}

func (m *PoolMarketCap_AssetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovDerivatives(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.Price.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	l = m.Reserved.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	return n
}

func (m *Market) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovDerivatives(uint64(l))
	}
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovDerivatives(uint64(l))
	}
	return n
}

func (m *EventPriceIsNotFeeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Asset)
	if l > 0 {
		n += 1 + l + sovDerivatives(uint64(l))
	}
	return n
}

func (m *Reserve) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketType != 0 {
		n += 1 + sovDerivatives(uint64(m.MarketType))
	}
	l = m.Amount.Size()
	n += 1 + l + sovDerivatives(uint64(l))
	return n
}

func sovDerivatives(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDerivatives(x uint64) (n int) {
	return sovDerivatives(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.OpenedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenedHeight", wireType)
			}
			m.OpenedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenedHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenedBaseRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OpenedBaseRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenedQuoteRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OpenedQuoteRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingMargin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemainingMargin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeviedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeviedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeviedAmountNegative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeviedAmountNegative = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLeviedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastLeviedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionInstance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PositionInstance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerivatives(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerivatives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueriedPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueriedPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueriedPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValuationProfit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValuationProfit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingMarginValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemainingMarginValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveMargin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EffectiveMargin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarginMaintenanceRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarginMaintenanceRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerivatives(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerivatives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolAssetConf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolAssetConf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolAssetConf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TargetWeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerivatives(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerivatives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteTicker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteTicker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLptMintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseLptMintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLptRedeemFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseLptRedeemFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowingFeeRatePerHour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BorrowingFeeRatePerHour.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportLiquidationRewardRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportLiquidationRewardRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportLevyPeriodRewardRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportLevyPeriodRewardRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptedAssetsConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptedAssetsConf = append(m.AcceptedAssetsConf, PoolAssetConf{})
			if err := m.AcceptedAssetsConf[len(m.AcceptedAssetsConf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerivatives(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerivatives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolMarketCap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolMarketCap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolMarketCap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteTicker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteTicker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetInfo = append(m.AssetInfo, PoolMarketCap_AssetInfo{})
			if err := m.AssetInfo[len(m.AssetInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerivatives(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerivatives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolMarketCap_AssetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reserved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerivatives(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerivatives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Market) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Market: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Market: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerivatives(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerivatives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPriceIsNotFeeded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPriceIsNotFeeded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPriceIsNotFeeded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerivatives(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerivatives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketType", wireType)
			}
			m.MarketType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketType |= MarketType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDerivatives
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDerivatives
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDerivatives(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDerivatives
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDerivatives(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDerivatives
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDerivatives
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDerivatives
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDerivatives
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDerivatives
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDerivatives        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDerivatives          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDerivatives = fmt.Errorf("proto: unexpected end of group")
)
